import pytest
import json
from pathlib import Path
from src.infrastructure.telemetry import Telemetry


def test_lsp_events_schema_pr1():
    # 1. Trigger events
    # We can invoke logic directly or mock
    # Let's rely on standard run if possible, but unit test is safer for restoration.

    t = Telemetry(Path.cwd())
    t.event("lsp.spawn", {}, {"status": "ok"}, 1, lsp_state="WARMING")
    t.event("lsp.fallback", {}, {"status": "ok"}, 0, reason="test", fallback_to="ast")

    events_file = Path("_ctx/telemetry/events.jsonl")
    lines = events_file.read_text().splitlines()
    last_events = [json.loads(l) for l in lines[-2:]]

    required_keys = {
        "ts",
        "run_id",
        "segment_id",
        "cmd",
        "args",
        "result",
        "timing_ms",
        "warnings",
        "x",
    }

    for e in last_events:
        assert required_keys.issubset(e.keys())
        assert isinstance(e["x"], dict)
        # Ensure no accidental top-level leak
        assert "reason" not in e
        assert "fallback_to" not in e
        assert "lsp_state" not in e

        if e["cmd"] == "lsp.spawn":
            assert e["x"]["lsp_state"] == "WARMING"

        if e["cmd"] == "lsp.fallback":
            assert e["x"]["reason"] == "test"


def test_no_absolute_paths_in_events():
    """Tripwire: ensure no PII/absolute paths in telemetry."""
    # Trigger events with potentially absolute paths
    t = Telemetry(Path.cwd())
    t.event("lsp.spawn", {"executable": "/abs/path/to/pylsp"}, {}, 1)

    # In real usage, the client sanitizes. This test checks the file content
    # But wait, t.event writes what's given. logic is in lsp_client.
    # So we should test LSPClient logic or simply parse the file and check constraints?
    # The requirement is "Tripwire test that fails if an event violates".
    # So we should run the CLI/Client code that generates the event.

    from src.infrastructure.lsp_client import LSPClient

    client = LSPClient(Path.cwd(), t)
    # Mock start to emit spawn event without actual process?
    # Or just rely on the integration test approach: run real code, check file.
    # Let's read the *last* events generated by previous tests/runs in this file.

    # Actually, let's just create a new client and run start (it will fail or succeed but log)
    # We need to rely on what `LSPClient` does.
    # But start() checks for binary.

    # Better: This test inspects the events.jsonl file for ANY violation
    # by running the actual client logic that claims to sanitize.

    # Force a spawn
    try:
        client.start()
    finally:
        client.stop()

    events_file = Path("_ctx/telemetry/events.jsonl")
    lines = events_file.read_text().splitlines()
    last_run_events = [json.loads(l) for l in lines if json.loads(l)["run_id"] == t.run_id]

    for e in last_run_events:
        # Check values in args and x
        payload_str = json.dumps(e)
        # Simple heuristic for absolute paths: "/Users/" or starts with "/" and has length > 20?
        # User requested: "/Users/" or "C:\\"
        assert "/Users/" not in payload_str, f"Absolute path detected in {e}"
        assert "C:\\" not in payload_str, f"Windows Absolute path detected in {e}"


def test_timing_ms_min_1_for_lsp_events():
    """Tripwire: ensure timing_ms >= 1."""
    t = Telemetry(Path.cwd())
    # Try to log 0
    t.event("lsp.test_zero", {}, {}, 0)

    events_file = Path("_ctx/telemetry/events.jsonl")
    lines = events_file.read_text().splitlines()
    e = json.loads(lines[-1])

    assert e["cmd"] == "lsp.test_zero"
    assert e["timing_ms"] >= 1, f"Timing should be >= 1, got {e['timing_ms']}"
