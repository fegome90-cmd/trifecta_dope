version: 1
id: WO-P2.2
epic_id: E-0001
title: "AST Cache File Locks & Concurrency Safety"
priority: P0
status: active
owner: null

scope:
  allow:
    - "src/domain/ast_cache.py"
    - "tests/integration/test_ast_cache_concurrency.py"
  deny:
    - ".env*"

verify:
  commands:
    - "uv run pytest -q tests/integration/test_ast_cache_concurrency.py"
    - "uv run pytest -q tests/integration/test_ast_cache_telemetry.py"

dod_id: DOD-DEFAULT

x_objective: |
  Implementar file locking en SQLiteCache para prevenir corrupción por acceso concurrente.

  Estrategia fail-closed:
  - Lock no disponible → Error explícito (NO fallback silencioso)
  - Timeout configurable (default: 5s)
  - Telemetría: ast.cache.lock_timeout

x_deliverables:
  - "File lock wrapper en SQLiteCache"
  - "Timeout + error handling"
  - "Telemetry event for lock contention"
  - "E2E concurrency test"

x_acceptance_criteria:
  - "SQLiteCache adquiere lock antes de writes"
  - "Lock timeout emite evento + error"
  - "Test concurrente: 2 procesos no corrompen DB"
  - "Telemetría muestra lock_timeout si ocurre"

diff_budget:
  max_files: 5
  max_loc: 200

x_risks:
  - "fcntl no disponible en Windows (usar filelock library cross-platform)"
  - "Lock granularity: per-operation vs per-transaction"
  - "Deadlock si lock no se libera (usar context manager)"

x_notes: |
  Usar biblioteca `filelock` para cross-platform compatibility.
  Lock file: {db_path}.lock
