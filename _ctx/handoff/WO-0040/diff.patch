diff --git a/_ctx/telemetry/events.jsonl b/_ctx/telemetry/events.jsonl
index b0cb1f5..cf49493 100644
--- a/_ctx/telemetry/events.jsonl
+++ b/_ctx/telemetry/events.jsonl
@@ -5129,3 +5129,5 @@
 {"ts": "2026-02-10T13:09:04-0300", "run_id": "run_1770739744", "segment_id": "6f25e381", "cmd": "ctx.sync.stub_regen", "args": {"stub_name": "repo_map.md"}, "result": {"regen_ok": true, "reason": ""}, "timing_ms": 1, "warnings": [], "x": {}}
 {"ts": "2026-02-10T13:09:04-0300", "run_id": "run_1770739744", "segment_id": "6f25e381", "cmd": "ctx.sync.stub_regen", "args": {"stub_name": "symbols_stub.md"}, "result": {"regen_ok": true, "reason": ""}, "timing_ms": 1, "warnings": [], "x": {}}
 {"ts": "2026-02-10T13:09:04-0300", "run_id": "run_1770739744", "segment_id": "6f25e381", "cmd": "ctx.sync", "args": {"segment": "."}, "result": {"status": "ok"}, "timing_ms": 334, "warnings": [], "x": {}}
+{"ts": "2026-02-13T14:29:30-0300", "run_id": "run_1771003770", "segment_id": "af11e67e", "cmd": "ast.hover.wip", "args": {"segment": ".", "uri": "src/infrastructure/cli.py", "line": 42, "char": 1}, "result": {"status": "ok", "backend": "wip_stub"}, "timing_ms": 1, "warnings": [], "x": {}}
+{"ts": "2026-02-13T14:33:45-0300", "run_id": "run_1771004025", "segment_id": "af11e67e", "cmd": "lsp.fallback", "args": {"method": "hover", "uri": "src/infrastructure/cli.py", "line": 42, "char": 1}, "result": {"status": "degraded", "reason": "lsp_binary_not_found"}, "timing_ms": 1, "warnings": [], "x": {"fallback_reason": "lsp_binary_not_found"}}
diff --git a/_ctx/telemetry/last_run.json b/_ctx/telemetry/last_run.json
index 660732b..eaacb97 100644
--- a/_ctx/telemetry/last_run.json
+++ b/_ctx/telemetry/last_run.json
@@ -1,7 +1,7 @@
 {
-  "run_id": "run_1770739744",
-  "segment_id": "6f25e381",
-  "ts": "2026-02-10 13:09:04",
+  "run_id": "run_1771004025",
+  "segment_id": "af11e67e",
+  "ts": "2026-02-13 14:33:45",
   "ast": {
     "ast_parse_count": 0,
     "ast_cache_hit_count": 0,
diff --git a/src/domain/lsp_contracts.py b/src/domain/lsp_contracts.py
new file mode 100644
index 0000000..ef0471b
--- /dev/null
+++ b/src/domain/lsp_contracts.py
@@ -0,0 +1,166 @@
+"""LSP Response Contracts - Explicit Fallback Protocol.
+
+This module defines the contract for LSP responses with explicit fallback handling.
+No silent fallbacks allowed - every degraded response must declare its state.
+"""
+
+from enum import Enum
+from typing import Dict, Any, Optional
+from dataclasses import dataclass, asdict
+
+
+class CapabilityState(str, Enum):
+    """Capability state of the LSP response."""
+
+    FULL = "FULL"  # LSP fully operational, real data
+    DEGRADED = "DEGRADED"  # Fallback to AST/limited functionality
+    WIP = "WIP"  # Work in progress, not fully implemented
+    UNAVAILABLE = "UNAVAILABLE"  # LSP not available
+
+
+class FallbackReason(str, Enum):
+    """Reason for fallback to degraded mode."""
+
+    LSP_NOT_READY = "lsp_not_ready"  # LSP warming or failed
+    LSP_BINARY_NOT_FOUND = "lsp_binary_not_found"  # pyright/pylsp not installed
+    LSP_REQUEST_TIMEOUT = "lsp_request_timeout"  # Request timed out
+    LSP_NOT_IMPLEMENTED = "lsp_not_implemented"  # Feature not yet implemented
+    LSP_ERROR = "lsp_error"  # LSP returned error
+    DAEMON_UNAVAILABLE = "daemon_unavailable"  # LSP daemon not running
+
+
+class ResponseState(str, Enum):
+    """State of the response itself."""
+
+    COMPLETE = "complete"  # Full response with all data
+    PARTIAL = "partial"  # Partial data (fallback)
+    ERROR = "error"  # Error occurred
+    DEGRADED = "degraded"  # Explicitly degraded
+
+
+class Backend(str, Enum):
+    """Backend that served the response."""
+
+    LSP_PYRIGHT = "lsp_pyright"  # Real LSP via pyright
+    LSP_PYLSP = "lsp_pylsp"  # Real LSP via pylsp
+    AST_ONLY = "ast_only"  # AST-only fallback
+    WIP_STUB = "wip_stub"  # WIP implementation stub
+    UNAVAILABLE = "unavailable"  # No backend available
+
+
+@dataclass
+class LSPResponse:
+    """Standard LSP response structure with explicit fallback contract.
+
+    Every response must include:
+    - capability_state: Actual capability state
+    - fallback_reason: Why degraded (if applicable)
+    - backend: What served the response
+    - response_state: State of this response
+
+    No silent fallbacks allowed.
+    """
+
+    status: str  # "ok" or "error"
+    capability_state: str  # CapabilityState value
+    backend: str  # Backend value
+    response_state: str  # ResponseState value
+    fallback_reason: Optional[str] = None  # FallbackReason value, required if degraded
+    data: Optional[Dict[str, Any]] = None
+    error_code: Optional[str] = None  # Required if status == "error"
+    message: Optional[str] = None  # Human readable, optional
+
+    def to_dict(self) -> Dict[str, Any]:
+        """Convert to dictionary for JSON serialization."""
+        result = asdict(self)
+        # Remove None values for cleaner JSON
+        return {k: v for k, v in result.items() if v is not None}
+
+    @classmethod
+    def full_response(
+        cls,
+        data: Dict[str, Any],
+        backend: Backend = Backend.LSP_PYRIGHT,
+    ) -> "LSPResponse":
+        """Create a full LSP response."""
+        return cls(
+            status="ok",
+            capability_state=CapabilityState.FULL.value,
+            backend=backend.value,
+            response_state=ResponseState.COMPLETE.value,
+            data=data,
+        )
+
+    @classmethod
+    def degraded_response(
+        cls,
+        fallback_reason: FallbackReason,
+        backend: Backend = Backend.AST_ONLY,
+        data: Optional[Dict[str, Any]] = None,
+        message: Optional[str] = None,
+    ) -> "LSPResponse":
+        """Create an explicit degraded response."""
+        return cls(
+            status="ok",
+            capability_state=CapabilityState.DEGRADED.value,
+            backend=backend.value,
+            response_state=ResponseState.DEGRADED.value,
+            fallback_reason=fallback_reason.value,
+            data=data,
+            message=message,
+        )
+
+    @classmethod
+    def wip_response(
+        cls,
+        data: Optional[Dict[str, Any]] = None,
+        message: Optional[str] = "Work in progress",
+    ) -> "LSPResponse":
+        """Create a WIP response."""
+        return cls(
+            status="ok",
+            capability_state=CapabilityState.WIP.value,
+            backend=Backend.WIP_STUB.value,
+            response_state=ResponseState.PARTIAL.value,
+            fallback_reason=FallbackReason.LSP_NOT_IMPLEMENTED.value,
+            data=data,
+            message=message,
+        )
+
+    @classmethod
+    def error_response(
+        cls,
+        error_code: str,
+        fallback_reason: FallbackReason,
+        message: str,
+        backend: Backend = Backend.UNAVAILABLE,
+    ) -> "LSPResponse":
+        """Create a fail-closed error response.
+
+        Use this when the operation requires LSP and cannot fallback.
+        """
+        return cls(
+            status="error",
+            capability_state=CapabilityState.UNAVAILABLE.value,
+            backend=backend.value,
+            response_state=ResponseState.ERROR.value,
+            fallback_reason=fallback_reason.value,
+            error_code=error_code,
+            message=message,
+        )
+
+    @classmethod
+    def unavailable_response(
+        cls,
+        fallback_reason: FallbackReason = FallbackReason.LSP_BINARY_NOT_FOUND,
+        message: Optional[str] = None,
+    ) -> "LSPResponse":
+        """Create an unavailable response when LSP is not accessible."""
+        return cls(
+            status="ok",
+            capability_state=CapabilityState.UNAVAILABLE.value,
+            backend=Backend.UNAVAILABLE.value,
+            response_state=ResponseState.DEGRADED.value,
+            fallback_reason=fallback_reason.value,
+            message=message or "LSP backend unavailable",
+        )
diff --git a/src/infrastructure/cli_ast.py b/src/infrastructure/cli_ast.py
index 0699eeb..2551291 100644
--- a/src/infrastructure/cli_ast.py
+++ b/src/infrastructure/cli_ast.py
@@ -9,6 +9,13 @@ from src.application.symbol_selector import SymbolQuery
 from src.application.ast_parser import SkeletonMapBuilder, ParseResult
 from src.domain.ast_cache import SQLiteCache
 from src.infrastructure.factories import get_ast_cache, get_ast_cache_db_path
+from src.domain.lsp_contracts import (
+    LSPResponse,
+    CapabilityState,
+    FallbackReason,
+    ResponseState,
+    Backend,
+)
 
 ast_app = typer.Typer(help="AST & Parsing Commands")
 
@@ -23,6 +30,34 @@ def _get_telemetry(level: str = "lite") -> Optional[Telemetry]:
     return Telemetry(Path.cwd(), level=level)
 
 
+def _emit_fallback_telemetry(
+    telemetry: Optional[Telemetry],
+    reason: FallbackReason,
+    method: str,
+    **kwargs,
+) -> None:
+    """Emit lsp.fallback event with explicit reason."""
+    if telemetry:
+        telemetry.event(
+            "lsp.fallback",
+            {"method": method, **kwargs},
+            {"status": "degraded", "reason": reason.value},
+            1,
+            fallback_reason=reason.value,
+        )
+        telemetry.flush()
+
+
+def _check_lsp_availability() -> tuple[bool, Optional[FallbackReason]]:
+    import shutil
+
+    executable = shutil.which("pylsp") or shutil.which("pyright-langserver")
+    if not executable:
+        return False, FallbackReason.LSP_BINARY_NOT_FOUND
+
+    return True, None
+
+
 CACHE_DIR_NAME = ".trifecta"
 
 
@@ -170,29 +205,57 @@ def hover(
     line: int = typer.Option(..., "--line", "-l"),
     character: int = typer.Option(..., "--char", "-c"),
     segment: str = typer.Option(".", "--segment"),
+    require_lsp: bool = typer.Option(
+        False, "--require-lsp", help="Fail if LSP unavailable (no fallback)"
+    ),
 ):
-    """[WIP] LSP Hover request."""
+    """LSP Hover request with explicit fallback contract."""
     telemetry = _get_telemetry("lite")
+    root = Path(segment).resolve()
+
+    is_lsp_available, fallback_reason = _check_lsp_availability()
+
+    if not is_lsp_available:
+        _emit_fallback_telemetry(
+            telemetry,
+            fallback_reason or FallbackReason.LSP_NOT_READY,
+            "hover",
+            uri=str(uri),
+            line=line,
+            char=character,
+        )
+
+        if require_lsp:
+            response = LSPResponse.error_response(
+                error_code="LSP_UNAVAILABLE",
+                fallback_reason=fallback_reason or FallbackReason.LSP_NOT_READY,
+                message=f"LSP unavailable: {(fallback_reason or FallbackReason.LSP_NOT_READY).value}",
+            )
+            _json_output(response.to_dict())
+            raise typer.Exit(1)
+        else:
+            response = LSPResponse.wip_response(
+                data={"uri": uri, "line": line, "char": character, "note": "LSP unavailable"},
+                message=f"LSP unavailable. Install pyright or pylsp for full functionality.",
+            )
+            _json_output(response.to_dict())
+            return
+
+    response = LSPResponse.wip_response(
+        data={"uri": uri, "line": line, "char": character, "lsp": "detected"},
+        message="Hover not yet implemented. LSP detected but not connected.",
+    )
+
     if telemetry:
         telemetry.event(
             "ast.hover.wip",
-            {"segment": segment, "uri": uri, "line": line, "char": character},
-            {"status": "ok", "backend": "wip_stub"},
+            {"segment": str(root), "uri": uri, "line": line, "char": character},
+            {"status": "ok", "backend": Backend.WIP_STUB.value, "lsp_available": True},
             1,
         )
         telemetry.flush()
 
-    # Stub for now
-    _json_output(
-        {
-            "status": "ok",
-            "kind": "skeleton",
-            "backend": "wip_stub",
-            "capability_state": "WIP",
-            "response_state": "partial",
-            "data": {"uri": uri, "range": {"start_line": 1, "end_line": 10}, "children": []},
-        }
-    )
+    _json_output(response.to_dict())
 
 
 @ast_app.command("clear-cache")
diff --git a/tests/integration/test_lsp_contract_fallback.py b/tests/integration/test_lsp_contract_fallback.py
new file mode 100644
index 0000000..894d414
--- /dev/null
+++ b/tests/integration/test_lsp_contract_fallback.py
@@ -0,0 +1,266 @@
+"""Tests for LSP explicit fallback contract (WO-0040).
+
+Verifies that no silent fallbacks exist - every degraded response
+must include capability_state, fallback_reason, backend, response_state.
+"""
+
+import json
+import subprocess
+import sys
+from pathlib import Path
+
+import pytest
+
+from src.domain.lsp_contracts import (
+    LSPResponse,
+    CapabilityState,
+    FallbackReason,
+    ResponseState,
+    Backend,
+)
+
+
+class TestLSPResponseContract:
+    """Unit tests for LSPResponse dataclass and factory methods."""
+
+    def test_full_response_structure(self):
+        """Full response must include all contract fields."""
+        data = {"symbol": "test", "type": "function"}
+        response = LSPResponse.full_response(data, backend=Backend.LSP_PYRIGHT)
+
+        result = response.to_dict()
+
+        assert result["status"] == "ok"
+        assert result["capability_state"] == CapabilityState.FULL.value
+        assert result["backend"] == Backend.LSP_PYRIGHT.value
+        assert result["response_state"] == ResponseState.COMPLETE.value
+        assert "fallback_reason" not in result  # Not needed for full responses
+        assert result["data"] == data
+
+    def test_degraded_response_includes_fallback_reason(self):
+        """Degraded response MUST include fallback_reason."""
+        response = LSPResponse.degraded_response(
+            fallback_reason=FallbackReason.LSP_NOT_READY,
+            backend=Backend.AST_ONLY,
+            data={"partial": True},
+        )
+
+        result = response.to_dict()
+
+        assert result["status"] == "ok"
+        assert result["capability_state"] == CapabilityState.DEGRADED.value
+        assert result["fallback_reason"] == FallbackReason.LSP_NOT_READY.value
+        assert result["backend"] == Backend.AST_ONLY.value
+        assert result["response_state"] == ResponseState.DEGRADED.value
+        assert result["data"] == {"partial": True}
+
+    def test_wip_response_structure(self):
+        """WIP response must declare WIP state and NOT_IMPLEMENTED reason."""
+        response = LSPResponse.wip_response(
+            data={"stub": True},
+            message="Work in progress",
+        )
+
+        result = response.to_dict()
+
+        assert result["status"] == "ok"
+        assert result["capability_state"] == CapabilityState.WIP.value
+        assert result["backend"] == Backend.WIP_STUB.value
+        assert result["response_state"] == ResponseState.PARTIAL.value
+        assert result["fallback_reason"] == FallbackReason.LSP_NOT_IMPLEMENTED.value
+
+    def test_error_response_for_fail_closed(self):
+        """Error response for fail-closed scenarios."""
+        response = LSPResponse.error_response(
+            error_code="LSP_UNAVAILABLE",
+            fallback_reason=FallbackReason.LSP_BINARY_NOT_FOUND,
+            message="LSP not available",
+        )
+
+        result = response.to_dict()
+
+        assert result["status"] == "error"
+        assert result["error_code"] == "LSP_UNAVAILABLE"
+        assert result["capability_state"] == CapabilityState.UNAVAILABLE.value
+        assert result["fallback_reason"] == FallbackReason.LSP_BINARY_NOT_FOUND.value
+        assert result["response_state"] == ResponseState.ERROR.value
+
+    def test_unavailable_response_structure(self):
+        """Unavailable response for when LSP is not accessible."""
+        response = LSPResponse.unavailable_response(
+            fallback_reason=FallbackReason.LSP_BINARY_NOT_FOUND,
+        )
+
+        result = response.to_dict()
+
+        assert result["status"] == "ok"
+        assert result["capability_state"] == CapabilityState.UNAVAILABLE.value
+        assert result["fallback_reason"] == FallbackReason.LSP_BINARY_NOT_FOUND.value
+        assert result["response_state"] == ResponseState.DEGRADED.value
+
+
+class TestHoverExplicitFallback:
+    """Integration tests for hover command with explicit fallback."""
+
+    def test_hover_returns_explicit_fallback_when_lsp_unavailable(self, tmp_path: Path):
+        """Hover must return explicit fallback contract when LSP unavailable.
+
+        Contract verification:
+        - capability_state: WIP or UNAVAILABLE
+        - fallback_reason: enum value
+        - backend: wip_stub or unavailable
+        - response_state: partial or degraded
+        - NO silent "status: ok" without capability_state
+        """
+        # Create minimal segment
+        (tmp_path / "skill.md").write_text("# Test")
+        ctx_dir = tmp_path / "_ctx"
+        ctx_dir.mkdir()
+        (ctx_dir / "agent_test.md").write_text("# Agent")
+        (ctx_dir / "prime_test.md").write_text("# Prime")
+        (ctx_dir / "session_test.md").write_text("# Session")
+
+        # Create test file
+        test_file = tmp_path / "test.py"
+        test_file.write_text("def foo(): pass")
+
+        result = subprocess.run(
+            [
+                sys.executable,
+                "-m",
+                "src.infrastructure.cli",
+                "ast",
+                "hover",
+                str(test_file),
+                "--line",
+                "1",
+                "--char",
+                "1",
+                "--segment",
+                str(tmp_path),
+            ],
+            capture_output=True,
+            text=True,
+            cwd=str(tmp_path),
+        )
+
+        # Should succeed (exit 0) but with explicit fallback
+        assert result.returncode == 0, (
+            f"Expected exit 0, got {result.returncode}. stderr: {result.stderr}"
+        )
+
+        output = json.loads(result.stdout)
+
+        # CONTRACT VERIFICATION: Must have explicit fallback fields
+        assert "capability_state" in output, "Missing capability_state - silent fallback detected!"
+        assert "fallback_reason" in output, "Missing fallback_reason - silent fallback detected!"
+        assert "backend" in output, "Missing backend - silent fallback detected!"
+        assert "response_state" in output, "Missing response_state - silent fallback detected!"
+
+        # Values must be from valid enum sets
+        assert output["capability_state"] in [s.value for s in CapabilityState]
+        assert output["fallback_reason"] in [r.value for r in FallbackReason]
+        assert output["backend"] in [b.value for b in Backend]
+        assert output["response_state"] in [s.value for s in ResponseState]
+
+    def test_hover_fail_closed_with_require_lsp(self, tmp_path: Path):
+        """Hover with --require-lsp must fail closed when LSP unavailable."""
+        # Create minimal segment
+        (tmp_path / "skill.md").write_text("# Test")
+        ctx_dir = tmp_path / "_ctx"
+        ctx_dir.mkdir()
+        (ctx_dir / "agent_test.md").write_text("# Agent")
+        (ctx_dir / "prime_test.md").write_text("# Prime")
+        (ctx_dir / "session_test.md").write_text("# Session")
+
+        test_file = tmp_path / "test.py"
+        test_file.write_text("def foo(): pass")
+
+        result = subprocess.run(
+            [
+                sys.executable,
+                "-m",
+                "src.infrastructure.cli",
+                "ast",
+                "hover",
+                str(test_file),
+                "--line",
+                "1",
+                "--char",
+                "1",
+                "--segment",
+                str(tmp_path),
+                "--require-lsp",
+            ],
+            capture_output=True,
+            text=True,
+            cwd=str(tmp_path),
+        )
+
+        # Should fail with exit code 1
+        assert result.returncode == 1, (
+            f"Expected exit 1 with --require-lsp, got {result.returncode}"
+        )
+
+        output = json.loads(result.stdout)
+
+        # CONTRACT VERIFICATION: Error response must include all fields
+        assert output["status"] == "error"
+        assert "error_code" in output
+        assert "fallback_reason" in output
+        assert output["capability_state"] == CapabilityState.UNAVAILABLE.value
+
+    def test_hover_no_silent_ok_without_capability_state(self, tmp_path: Path):
+        """TRIPWIRE: Any response with status=ok MUST have capability_state.
+
+        This test ensures we never regress to silent fallbacks.
+        """
+        # Create minimal segment
+        (tmp_path / "skill.md").write_text("# Test")
+        ctx_dir = tmp_path / "_ctx"
+        ctx_dir.mkdir()
+        (ctx_dir / "agent_test.md").write_text("# Agent")
+        (ctx_dir / "prime_test.md").write_text("# Prime")
+        (ctx_dir / "session_test.md").write_text("# Session")
+
+        test_file = tmp_path / "test.py"
+        test_file.write_text("def foo(): pass")
+
+        result = subprocess.run(
+            [
+                sys.executable,
+                "-m",
+                "src.infrastructure.cli",
+                "ast",
+                "hover",
+                str(test_file),
+                "--line",
+                "1",
+                "--char",
+                "1",
+                "--segment",
+                str(tmp_path),
+            ],
+            capture_output=True,
+            text=True,
+            cwd=str(tmp_path),
+        )
+
+        output = json.loads(result.stdout)
+
+        # INVARIANT: status=ok implies capability_state present
+        if output.get("status") == "ok":
+            assert "capability_state" in output, (
+                f"VIOLATION: status=ok without capability_state - silent fallback! Output: {output}"
+            )
+
+
+class TestFallbackTelemetryEvents:
+    """Verify lsp.fallback events are emitted correctly."""
+
+    def test_fallback_event_includes_reason(self, tmp_path: Path):
+        """lsp.fallback event must always include explicit reason."""
+        # This would require checking telemetry output
+        # For now, we verify the contract structure is in place
+        # Full telemetry verification would need integration with telemetry system
+        pass
diff --git a/uv.lock b/uv.lock
index de040bb..0d2a305 100644
--- a/uv.lock
+++ b/uv.lock
@@ -1794,15 +1794,15 @@ wheels = [
 
 [[package]]
 name = "pyright"
-version = "1.1.407"
+version = "1.1.408"
 source = { registry = "https://pypi.org/simple" }
 dependencies = [
     { name = "nodeenv" },
     { name = "typing-extensions" },
 ]
-sdist = { url = "https://files.pythonhosted.org/packages/a6/1b/0aa08ee42948b61745ac5b5b5ccaec4669e8884b53d31c8ec20b2fcd6b6f/pyright-1.1.407.tar.gz", hash = "sha256:099674dba5c10489832d4a4b2d302636152a9a42d317986c38474c76fe562262", size = 4122872, upload-time = "2025-10-24T23:17:15.145Z" }
+sdist = { url = "https://files.pythonhosted.org/packages/74/b2/5db700e52554b8f025faa9c3c624c59f1f6c8841ba81ab97641b54322f16/pyright-1.1.408.tar.gz", hash = "sha256:f28f2321f96852fa50b5829ea492f6adb0e6954568d1caa3f3af3a5f555eb684", size = 4400578, upload-time = "2026-01-08T08:07:38.795Z" }
 wheels = [
-    { url = "https://files.pythonhosted.org/packages/dc/93/b69052907d032b00c40cb656d21438ec00b3a471733de137a3f65a49a0a0/pyright-1.1.407-py3-none-any.whl", hash = "sha256:6dd419f54fcc13f03b52285796d65e639786373f433e243f8b94cf93a7444d21", size = 5997008, upload-time = "2025-10-24T23:17:13.159Z" },
+    { url = "https://files.pythonhosted.org/packages/0c/82/a2c93e32800940d9573fb28c346772a14778b84ba7524e691b324620ab89/pyright-1.1.408-py3-none-any.whl", hash = "sha256:090b32865f4fdb1e0e6cd82bf5618480d48eecd2eb2e70f960982a3d9a4c17c1", size = 6399144, upload-time = "2026-01-08T08:07:37.082Z" },
 ]
 
 [[package]]
@@ -2594,7 +2594,7 @@ requires-dist = [
     { name = "plotly", marker = "extra == 'telemetry'", specifier = ">=5.18.0" },
     { name = "pydantic", specifier = ">=2.0" },
     { name = "pyrefly", marker = "extra == 'dev'" },
-    { name = "pyright", marker = "extra == 'dev'", specifier = "==1.1.407" },
+    { name = "pyright", marker = "extra == 'dev'", specifier = "==1.1.408" },
     { name = "pytest", marker = "extra == 'dev'", specifier = ">=7.0" },
     { name = "pytest-cov", marker = "extra == 'dev'" },
     { name = "pyyaml", specifier = ">=6.0" },
