| # | Punto del Pipeline | Concepto | Beneficio | Riesgo | Cambios | Dependencias | Métrica Validación |
|---|-------------------|----------|-----------|--------|---------|--------------|-------------------|
| **O1** | `cli.py` → UseCase wrappers | **Bundle** | Capturar prompt + args de cada comando CLI para replay | Log bloat si no hay rotation policy | MIN: Agregar `BundleRecorder.start_session()` al inicio de cada comando | Manifest schema v1 | `bundle_replay_success_rate` |
| **O2** | `Telemetry.event()` → events.jsonl | **Bundle** | Re-usar eventos existentes como parte del bundle (tool_calls timeline) | Eventos actuales no tienen `tool_call_id` ni `parent_id` para grafo | MID: Extender event schema con `tool_call_id`, `parent_trace_id`, `execution_order` | Refactor Telemetry event signature | `bundle_event_completeness` (% eventos con tool_call_id) |
| **O3** | `ContextService.search()` | **Bundle** | Grabar query + hits + scores como "search tool call" para bundle | Sin instrumentación actual de "qué chunk fue efectivamente útil" | MIN: Wrapper que loggea `search_request` + `search_response` a bundle events | ContextBundleRecorder | `search_tool_call_count` |
| **O4** | `ContextService.get()` | **Bundle** | Grabar IDs solicitados + modo + texto entregado (con redaction rules) | Texto completo puede explotar bundle size (MBs) | HIGH: Implementar redaction policy (PII, sec
