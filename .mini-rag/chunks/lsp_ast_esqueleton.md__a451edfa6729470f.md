emplace las referencias frágiles archivo:línea por un DSL de selectores (e.g., py://clase#metodo) que resista la deriva del código (code drift) durante refactorizaciones, garantizando la estabilidad de las referencias.4
1. Introducción: El Imperativo del Determinismo en la Ingeniería de Agentes
La integración de Grandes Modelos de Lenguaje (LLMs) en flujos de trabajo de ingeniería de software ha revelado una dicotomía fundamental: mientras los modelos operan en un espacio probabilístico de tokens y embeddings, el código fuente exige una precisión binaria y determinista. Un agente encargado de una refactorización no puede "alucinar" la ubicación de una definición de clase ni inferir aproximadamente la firma de una función; requiere una certeza absoluta sobre la estructura sintáctica y las relaciones semánticas del código.
La práctica estándar de utilizar Recuperación Aumentada por Generación (RAG) basada en embeddings vectoriales ha demostrado ser insuficiente para tareas de codificación complejas. Los embeddings capturan bien la similitud semántica del lenguaje natural (asociando "autenticación" con "login"), pero fallan catastróficamente al intentar distinguir entre métodos homónimos en diferentes ámbitos o al rastrear el flujo de control a través de interfaces polimórficas.5 La "vecindad" en el espacio vectorial no garantiza la relevancia en el grafo de ejecución del programa
